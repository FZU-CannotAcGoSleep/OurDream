
### [TJOI2013] 单词

建fail树，统计子树和


### [USACO15FEB]Censoring G

考虑它删除和拼接的过程，其实相当于在trie图上跳的过程，只要在枚举的时候顺便记一下现在在trie图上的哪个位置即可快速回溯


### [JSOI2007]文本生成器

考虑补集转化，把至少有一个转化成没有——>这个好处理，建出trie图（在这里也就是安全图），然后和ac自动机结合

dp[i][j]表示当前长度为i，在trie图上所在的点为j的答案，用j更新k，只要k满足它、它的fail、它fail的fail......没有一个出现过即可

这里有个小优化：可以在getfail时顺便维护一个flag数组，以及每个点的数组都要求。


### [USACO12JAN]Video Game G

每个子串都有得分，求长度为k时的最大得分，和上一题类似的，用dp[i][j]表示长度为i，在j时的最大得分

注意算贡献时，节点v的贡献要累加上它的fail、它fail的fail......同理，这个数组也可以在getfail过程中求出。


### [SDOI2014] 数数

ac自动机套数位dp，大胆魔改数位dp；实质仍是安全图问题，坑点在于S的集合中有前导0，而幸运数没有，会导致合法数误判，简单的处理方法是把trie[0][0]设置为0。

### [POI2000] 病毒

无限长的过程必然是某个循环元不断循环的过程，也就是说在trie图上不走危险节点能走出环。

找环用dfs（此题可过）

也可用tarjan(如果复杂度不对)

### CF1202E You Are Given Some Strings

直接枚举显然不可做，考虑枚举划分点i，如果能知道以i结尾的能匹配的字符串有多少就好了，联想到AC自动机多模式匹配；

还需要知道i+1的，字符串翻转一下再做一遍即可，乘法原理累加答案。




