
### [TJOI2013] 单词

建fail树，统计子树和


### [USACO15FEB]Censoring G

考虑它删除和拼接的过程，其实相当于在trie图上跳的过程，只要在枚举的时候顺便记一下现在在trie图上的哪个位置即可快速回溯


### [JSOI2007]文本生成器

考虑补集转化，把至少有一个转化成没有——>这个好处理，建出trie图（在这里也就是安全图），然后和ac自动机结合

dp[i][j]表示当前长度为i，在trie图上所在的点为j的答案，用j更新k，只要k满足它、它的fail、它fail的fail......没有一个出现过即可

这里有个小优化：可以在getfail时顺便维护一个flag数组，以及每个点的数组都要求。


### [USACO12JAN]Video Game G

每个子串都有得分，求长度为k时的最大得分，和上一题类似的，用dp[i][j]表示长度为i，在j时的最大得分

注意算贡献时，节点v的贡献要累加上它的fail、它fail的fail......同理，这个数组也可以在getfail过程中求出。


### [SDOI2014] 数数

ac自动机套数位dp，大胆魔改数位dp；实质仍是安全图问题，坑点在于S的集合中有前导0，而幸运数没有，会导致合法数误判，简单的处理方法是把trie[0][0]设置为0。

### [POI2000] 病毒

无限长的过程必然是某个循环元不断循环的过程，也就是说在trie图上不走危险节点能走出环。

找环用dfs（此题可过）

也可用tarjan(如果复杂度不对)

### CF1202E You Are Given Some Strings

直接枚举显然不可做，考虑枚举划分点i，如果能知道以i结尾的能匹配的字符串有多少就好了，联想到AC自动机多模式匹配；

还需要知道i+1的，字符串翻转一下再做一遍即可，乘法原理累加答案。

### 21黑龙江省赛E Elastic Search

考虑trie图上dp，显然i的值只能由fail[i]和fa[i]转移过来，dp[i][1]表示从根节点到i点在fail树上跳过一次的最长答案，dp[i][0]表示从根节点到i没跳过的方案

则转移有：

$$dp[v][1]=max(dp[u][1],max(dp[fail[v]][0],dp[fail[v]][1]))+trie[v].flag;$$
	
$$dp[v][0]=dp[u][0]+trie[v].flag;$$
 
$$ret=max(ret,max(dp[v][0],dp[v][1]));$$
 
最后返回ret即可

### HNOI2014 L语言

考虑dp[i]表示该字符串走到i点是否能被分解，转移的前驱则是i在fail树上的祖先(显然这些祖先一定是某个单词的结尾)

dp[i]|=dp[fails(i)];

暴力做时间过不去，加一个针对数据的减枝：若当前为止最大合法前缀+maxl(单词的最长长度)仍 < i ,则往下无解。

正解是状压预处理i点能跳到的fail长度，优化掉转移时跳fail的部分







